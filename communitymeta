#!/usr/bin/env python3

import shlex
import os
import sys
import subprocess
from pycman import config
import pyparsing
import argparse

metadir = os.path.expanduser("~/.communitymeta/")
syncurl = "git://github.com/ids1024/archcommunitymetadata"
handle = config.init_with_config("/etc/pacman.conf")

operator = pyparsing.Regex("!=|=").setName("operator")
text = pyparsing.Word(pyparsing.alphanums + '-_') | pyparsing.QuotedString('"')
condition = pyparsing.Group((text + operator + text) | text)

expr = pyparsing.operatorPrecedence(condition, [
                            ("not", 1, pyparsing.opAssoc.RIGHT),
                            ("and", 2, pyparsing.opAssoc.LEFT),
                            ("or", 2, pyparsing.opAssoc.LEFT)
                            ])

class EvaluationError(Exception):
    pass

def parseMetadata():
    # This could be stored in an sqlite database for speed
    syncpkgs = (pkg for db in handle.get_syncdbs() for pkg in db.pkgcache)
    packages = {}
    parsevars = []
    for package in syncpkgs:
        pacmeta = {}
        pacmeta['provide'] = package.provides
        pacmeta['depend'] = package.depends
        pacmeta['optdepend'] = package.optdepends
        pacmeta['group'] = package.groups
        pacmeta['replace'] = package.replaces
        pacmeta['conflict'] = package.conflicts
        pacmeta['license'] = package.licenses
        pacmeta['packager'] = [package.packager]
        pacmeta['repo'] = [package.db.name]
        if package.name in os.listdir(metadir):
            with open(metadir + package.name) as file:
                for line in file:
                    columns = shlex.split(line)
                    if not columns:
                        continue
                    pacmeta[columns[0]] = columns[1:]
        packages[package.name] = pacmeta
    for name, pacmeta in packages.items():
        for param, values in pacmeta.items():
            for i, value in enumerate(values.copy()):
                if value[0] == '$':
                    if '.' in value:
                        pac, param = value[1:].split('.', 1)
                        newvals = packages.get(pac, {}).get(param, [])
                    else:
                        newvals = pacmeta[value[1:]]
                    values.extend(newvals)
                    del values[i]
                    
    return packages

def sync():
    if not os.path.exists(metadir):
        returnval = subprocess.call(["git", "clone", syncurl, metadir])
    else:
        origdir = os.getcwd()
        os.chdir(metadir)
        returnval = subprocess.call(["git", "pull"])
        os.chdir(origdir)
    if returnval != 0:
        print("Error: git returned nonzero exit status")
        sys.exit(1)

def evaluateExpr(pacmeta, tokens):
    if len(tokens) == 1 and isinstance(tokens[0], str):
        return (tokens[0] in pacmeta) and ('false' not in pacmeta[tokens[0]])
    if len(tokens) == 1:
        return evaluateExpr(pacmeta, tokens[0])
    if len(tokens) == 2 and tokens[0] == 'not':
        return not evaluateExpr(pacmeta, tokens[1])

    operator = tokens[1]
    if operator in ('and', 'or'):
        values = (i if isinstance(i, bool) else evaluateExpr(pacmeta, i)
                  for i in tokens[::2]) # All but operators
        return ((operator == 'and' and all(values)) or
                (operator == 'or' and any(values)))
    elif operator in ('=', '!='):
        pacvalues = pacmeta.get(tokens[0], ())
        return ((operator == '=' and tokens[2] in pacvalues) or
                (operator == '!=' and tokens[2] not in pacvalues))
    else:
        # This code should never be reached; raise exception if it is
        raise EvaluationError


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
            description='Package metadata provided by the community')
    parser.add_argument('--sync', action='store_true',
            help='synchronize with server')
    parser.add_argument('query', nargs='?', default='')
    args = parser.parse_args()

    if args.sync:
        sync()
        sys.exit(0)
    if not os.path.exists(metadir):
        print("Metadata directory does not exist: running initial sync")
        sync()
    packages = parseMetadata().items()
    if not args.query:
        # Display all packages by default
        matches = (package for package, pacmeta in packages)
    else:
        try:
            tree = expr.parseString(args.query, parseAll=True)
        except pyparsing.ParseException as e:
            print("Error parsing query at column " + str(e.col))
            sys.exit(1)
        matches = (package for package, pacmeta in packages
                   if evaluateExpr(pacmeta, tree))
    print(*matches, sep='\n')
