#!/usr/bin/env python3

import shlex
import os
import sys
import subprocess
from pycman import config
import pyparsing

metadir = os.path.expanduser("~/.communitymeta/")
syncurl = "git://github.com/ids1024/archcommunitymetadata"
handle = config.init_with_config("/etc/pacman.conf")

operator = pyparsing.Regex("!=|=").setName("operator")
text = pyparsing.Word(pyparsing.alphanums + '-_')
condition = pyparsing.Group(text + operator + text)

expr = pyparsing.operatorPrecedence(condition,[
                            ("not", 1, pyparsing.opAssoc.RIGHT, ),
                            ("and", 2, pyparsing.opAssoc.LEFT, ),
                            ("or", 2, pyparsing.opAssoc.LEFT, ),
                            ])

class EvaluationError(Exception):
    pass

def parseMetadata():
    # This could be stored in an sqlite database for speed
    packages = []
    syncpkgs = [pkg for db in handle.get_syncdbs() for pkg in db.pkgcache]
    for package in syncpkgs:
        pacmeta = {}
        pacmeta['provide'] = package.provides
        pacmeta['depend'] = package.depends
        pacmeta['optdepend'] = package.optdepends
        pacmeta['group'] = package.groups
        pacmeta['replace'] = package.replaces
        pacmeta['conflict'] = package.conflicts
        pacmeta['license'] = package.licenses
        pacmeta['packager'] = [package.packager]
        pacmeta['repo'] = [package.db.name]
        if package.name in os.listdir(metadir):
            with open(metadir + package.name) as file:
                for line in file:
                    columns = shlex.split(line)
                    if not columns:
                        continue
                    pacmeta[columns[0]] = columns[1:]
        packages.append((package.name, pacmeta))
    return packages

def sync():
    if not os.path.exists(metadir):
        subprocess.call(["git", "clone", syncurl, metadir])
    else:
        origdir = os.getcwd()
        os.chdir(metadir)
        subprocess.call(["git", "pull"])
        os.chdir(origdir)

def evaluateExpr(pacmeta, tokens):
    if len(tokens) == 1:
        return evaluateExpr(pacmeta, tokens[0])
    if len(tokens) == 2 and tokens[0] == 'not':
        return not evaluateExpr(pacmeta, tokens[1])

    left = tokens[0]
    operator = tokens[1]
    right = tokens[2]
    if operator in ('and', 'or'):
        if not isinstance(left, bool):
            left = evaluateExpr(pacmeta, left)
        if not isinstance(right, (str, bool)):
            right = evaluateExpr(pacmeta, right)
    elif operator in ('=', '!='):
        pacvalues = pacmeta.get(left, ())
    else:
        # This code should never be reached; raise exception if it is
        raise EvaluationError

    if ((operator == '=!' and (right not in pacvalues)) or
        (operator == '=' and (right in pacvalues)) or
        (operator == 'and' and (left and right)) or
        (operator == 'or' and (left or right))):
        return True
    return False


if __name__ == "__main__":
    if len(sys.argv) > 1 and sys.argv[1] == "--sync":
        sync()
        sys.exit(0)
    packages = parseMetadata()
    params = []
    try:
        tree = expr.parseString(sys.argv[1], parseAll=True)
    except pyparsing.ParseException as e:
        print("Error parsing query at column " + str(e.col))
        sys.exit(1)
    for package, pacmeta in packages:
        if evaluateExpr(pacmeta, tree):
            print(package)
