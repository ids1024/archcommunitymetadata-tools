#!/usr/bin/env python3

import shlex
import os
import re
import sys
import subprocess
from pycman import config
import pyparsing
import argparse
import urllib.request
import json
import tarfile

metadir = os.path.expanduser("~/.communitymeta/")
syncurl = "git://github.com/ids1024/archcommunitymetadata"
pacneturl = "http://pacnet.archlinux.pl/api/packages/"
handle = config.init_with_config("/etc/pacman.conf")

operator = pyparsing.Regex("!=|=").setName("operator")
allowedchars = ''.join(set(pyparsing.printables) - set('!="'))
text = pyparsing.Word(allowedchars) | pyparsing.QuotedString('"')
condition = pyparsing.Group((text + operator + text) | text)

expr = pyparsing.operatorPrecedence(condition, [
                            ("not", 1, pyparsing.opAssoc.RIGHT),
                            ("and", 2, pyparsing.opAssoc.LEFT),
                            ("or", 2, pyparsing.opAssoc.LEFT)
                            ])
filelist = None

class EvaluationError(Exception):
    pass

def parseMetadata():
    # This could be stored in an sqlite database for speed
    with open(metadir + '.pacnet') as file:
        pacnet = json.load(file)
    categories = {package['name']: package['category__name']
                 for package in pacnet}
    syncpkgs = (pkg for db in handle.get_syncdbs() for pkg in db.pkgcache)
    packages = {}
    parsevars = []
    for package in syncpkgs:
        pacmeta = {}
        pacmeta['name'] = [package.name]
        pacmeta['provide'] = package.provides
        pacmeta['depend'] = package.depends
        pacmeta['optdepend'] = package.optdepends
        pacmeta['group'] = package.groups
        pacmeta['replace'] = package.replaces
        pacmeta['conflict'] = package.conflicts
        pacmeta['license'] = package.licenses
        pacmeta['packager'] = [package.packager]
        pacmeta['repo'] = [package.db.name]
        pacmeta['category'] = [categories.get(package.name, 'No')]
        if package.name in os.listdir(metadir):
            with open(metadir + package.name) as file:
                for line in file:
                    columns = shlex.split(line)
                    if not columns:
                        continue
                    pacmeta[columns[0]] = columns[1:]
        packages[package.name] = pacmeta
    for name, pacmeta in packages.items():
        for param, values in pacmeta.items():
            for i, value in enumerate(values.copy()):
                if value[0] == '$':
                    if '.' in value:
                        pac, param = value[1:].split('.', 1)
                        newvals = packages.get(pac, {}).get(param, [])
                    else:
                        newvals = pacmeta[value[1:]]
                    values.extend(newvals)
                    del values[i]
                    
    return packages

def sync():
    if not os.path.exists(metadir):
        returnval = subprocess.call(["git", "clone", syncurl, metadir])
    else:
        returnval = subprocess.call(["git", "-C", metadir, "pull"])
    if returnval != 0:
        print("Error: git returned nonzero exit status")
        sys.exit(1)
    origdir = os.getcwd()
    os.chdir(metadir)
    print("Getting file lists from sync dbs...")
    filelist = {}
    for db in handle.get_syncdbs():
        try:
            files = urllib.request.urlopen(
                       db.servers[0] + '/' + db.name + '.files')
            tar = tarfile.open(mode='r:gz', fileobj=files)
            filelist.update({i.name.rsplit('-', 2)[0]:
                             tar.extractfile(i).read().decode().splitlines()[1:]
                             for i in tar if i.name.endswith('/files')})
            tar.close()
        except urllib.error.HTTPError:
            print("Unable to find file list for repo " + db.name + ": Skipping")
    with open('.filelist', 'w') as file:
        json.dump(filelist, file)
    print("Syncing with pacnet...")
    pacnetdata = urllib.request.urlopen(pacneturl).read().decode()
    with open('.pacnet', 'w') as file:
        file.write(pacnetdata)
    os.chdir(origdir)

def evaluateExpr(pacmeta, tokens, regex):
    if len(tokens) == 1 and isinstance(tokens[0], str):
        return (tokens[0] in pacmeta) and ('false' not in pacmeta[tokens[0]])
    if len(tokens) == 1:
        return evaluateExpr(pacmeta, tokens[0], regex)
    if len(tokens) == 2 and tokens[0] == 'not':
        return not evaluateExpr(pacmeta, tokens[1], regex)

    operator = tokens[1]
    if operator in ('and', 'or'):
        values = (i if isinstance(i, bool) else
                  evaluateExpr(pacmeta, i, regex)
                  for i in tokens[::2]) # All but operators
        return ((operator == 'and' and all(values)) or
                (operator == 'or' and any(values)))
    elif operator in ('=', '!='):
        global filelist
        pacvalues = pacmeta.get(tokens[0], ())
        if tokens[0] == 'file':
            if not filelist:
                with open(metadir + '.filelist') as file:
                    filelist = json.load(file)
            pacvalues = filelist.get(pacmeta['name'][0])
        if regex:
            match = any(re.match(tokens[2], i) for i in pacvalues)
        else:
            match = tokens[2] in pacvalues
        return (operator == '=' and match) or (operator == '!=' and not match)
    else:
        # This code should never be reached; raise exception if it is
        raise EvaluationError


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
            description='Package metadata provided by the community')
    parser.add_argument('--sync', action='store_true',
            help='synchronize with server')
    parser.add_argument('-r', '--regex', action='store_true',
            help='support regular expressions in search')
    parser.add_argument('query', nargs='?', default='')
    args = parser.parse_args()

    if args.sync:
        sync()
        sys.exit(0)
    if not os.path.exists(metadir):
        print("Metadata directory does not exist: running initial sync")
        sync()
    packages = parseMetadata().items()
    if not args.query:
        # Display all packages by default
        matches = (package for package, pacmeta in packages)
    else:
        try:
            tree = expr.parseString(args.query, parseAll=True)
        except pyparsing.ParseException as e:
            print("Error parsing query at column " + str(e.col))
            sys.exit(1)
        matches = (package for package, pacmeta in packages
                   if evaluateExpr(pacmeta, tree, args.regex))
    print(*matches, sep='\n')
